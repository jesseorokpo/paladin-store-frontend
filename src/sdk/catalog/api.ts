/* tslint:disable */
/* eslint-disable */
/**
 * Catalog Docs
 * Basic store catalog management features
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Locker
 */
export interface Locker {
    /**
     * 
     * @type {string}
     * @memberof Locker
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Locker
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Locker
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof Locker
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof Locker
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof Locker
     */
    'pid': string;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {Array<OrderItem>}
     * @memberof Order
     */
    'items': Array<OrderItem>;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'payment_status': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'payment_url': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface OrderItem
 */
export interface OrderItem {
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    'product_name': string;
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    'product_id': string;
    /**
     * 
     * @type {number}
     * @memberof OrderItem
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof OrderItem
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof OrderItem
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'caption': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'handle': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'about': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'cover': string;
}
/**
 * 
 * @export
 * @interface Payout
 */
export interface Payout {
    /**
     * 
     * @type {string}
     * @memberof Payout
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Payout
     */
    'visibility': string;
    /**
     * 
     * @type {string}
     * @memberof Payout
     */
    'notes': string;
    /**
     * 
     * @type {string}
     * @memberof Payout
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof Payout
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Payout
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'handle': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'image': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Product
     */
    'collections': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'price_formated': string;
}
/**
 * 
 * @export
 * @interface PublishLockerDto
 */
export interface PublishLockerDto {
    /**
     * 
     * @type {string}
     * @memberof PublishLockerDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PublishLockerDto
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof PublishLockerDto
     */
    'type': PublishLockerDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PublishLockerDto
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof PublishLockerDto
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof PublishLockerDto
     */
    'image': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PublishLockerDto
     */
    'collections': Array<string>;
}

export const PublishLockerDtoTypeEnum = {
    Physical: 'physical',
    Digital: 'digital'
} as const;

export type PublishLockerDtoTypeEnum = typeof PublishLockerDtoTypeEnum[keyof typeof PublishLockerDtoTypeEnum];

/**
 * 
 * @export
 * @interface PublishOrderDto
 */
export interface PublishOrderDto {
    /**
     * 
     * @type {Array<OrderItem>}
     * @memberof PublishOrderDto
     */
    'items_spec': Array<OrderItem>;
    /**
     * 
     * @type {string}
     * @memberof PublishOrderDto
     */
    'locker_id': string;
}
/**
 * 
 * @export
 * @interface PublishPayoutDto
 */
export interface PublishPayoutDto {
    /**
     * 
     * @type {string}
     * @memberof PublishPayoutDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof PublishPayoutDto
     */
    'notes': string;
}
/**
 * 
 * @export
 * @interface PublishProductDto
 */
export interface PublishProductDto {
    /**
     * 
     * @type {string}
     * @memberof PublishProductDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PublishProductDto
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof PublishProductDto
     */
    'type': PublishProductDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PublishProductDto
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof PublishProductDto
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof PublishProductDto
     */
    'image': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PublishProductDto
     */
    'collections': Array<string>;
}

export const PublishProductDtoTypeEnum = {
    Physical: 'physical',
    Digital: 'digital'
} as const;

export type PublishProductDtoTypeEnum = typeof PublishProductDtoTypeEnum[keyof typeof PublishProductDtoTypeEnum];

/**
 * 
 * @export
 * @interface PublishTaxonomyDto
 */
export interface PublishTaxonomyDto {
    /**
     * 
     * @type {string}
     * @memberof PublishTaxonomyDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof PublishTaxonomyDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PublishTaxonomyDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof PublishTaxonomyDto
     */
    'parent_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublishTaxonomyDto
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublishTaxonomyDto
     */
    'as'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublishTaxonomyDto
     */
    'for'?: string;
}
/**
 * 
 * @export
 * @interface Taxonomy
 */
export interface Taxonomy {
    /**
     * 
     * @type {string}
     * @memberof Taxonomy
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Taxonomy
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Taxonomy
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Taxonomy
     */
    'handle': string;
    /**
     * 
     * @type {string}
     * @memberof Taxonomy
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Taxonomy
     */
    'parent_id': string;
    /**
     * 
     * @type {string}
     * @memberof Taxonomy
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof Taxonomy
     */
    'as': string;
    /**
     * 
     * @type {string}
     * @memberof Taxonomy
     */
    'for': string;
}
/**
 * 
 * @export
 * @interface UpdateLockerDto
 */
export interface UpdateLockerDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateLockerDto
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateLockerDto
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateLockerDto
     */
    'type': UpdateLockerDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateLockerDto
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLockerDto
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLockerDto
     */
    'image': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateLockerDto
     */
    'collections': Array<string>;
}

export const UpdateLockerDtoTypeEnum = {
    Physical: 'physical',
    Digital: 'digital'
} as const;

export type UpdateLockerDtoTypeEnum = typeof UpdateLockerDtoTypeEnum[keyof typeof UpdateLockerDtoTypeEnum];

/**
 * 
 * @export
 * @interface UpdateOrganizationDto
 */
export interface UpdateOrganizationDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'handle': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'about': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'vision_statement': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'facebook_handle': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'twitter_handle': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'instagram_handle': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'youtube_handle': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'linkedin_handle': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'website_handle': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'cover': string;
}
/**
 * 
 * @export
 * @interface UpdateProductDto
 */
export interface UpdateProductDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateProductDto
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'type': UpdateProductDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'image': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateProductDto
     */
    'collections': Array<string>;
}

export const UpdateProductDtoTypeEnum = {
    Physical: 'physical',
    Digital: 'digital'
} as const;

export type UpdateProductDtoTypeEnum = typeof UpdateProductDtoTypeEnum[keyof typeof UpdateProductDtoTypeEnum];

/**
 * 
 * @export
 * @interface UpdateTaxonomyDto
 */
export interface UpdateTaxonomyDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTaxonomyDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaxonomyDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaxonomyDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaxonomyDto
     */
    'parent_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaxonomyDto
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaxonomyDto
     */
    'as'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaxonomyDto
     */
    'for'?: string;
}

/**
 * LockerApi - axios parameter creator
 * @export
 */
export const LockerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockerControllerDeleteItem: async (item: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('lockerControllerDeleteItem', 'item', item)
            const localVarPath = `/api/catalog/Lockers/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockerControllerGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/catalog/Lockers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockerControllerGetById: async (item: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('lockerControllerGetById', 'item', item)
            const localVarPath = `/api/catalog/Lockers/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PublishLockerDto} publishLockerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockerControllerPublish: async (publishLockerDto: PublishLockerDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publishLockerDto' is not null or undefined
            assertParamExists('lockerControllerPublish', 'publishLockerDto', publishLockerDto)
            const localVarPath = `/api/catalog/Lockers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publishLockerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} item 
         * @param {UpdateLockerDto} updateLockerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockerControllerUpdate: async (item: string, updateLockerDto: UpdateLockerDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('lockerControllerUpdate', 'item', item)
            // verify required parameter 'updateLockerDto' is not null or undefined
            assertParamExists('lockerControllerUpdate', 'updateLockerDto', updateLockerDto)
            const localVarPath = `/api/catalog/Lockers/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLockerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LockerApi - functional programming interface
 * @export
 */
export const LockerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LockerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockerControllerDeleteItem(item: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockerControllerDeleteItem(item, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockerControllerGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Locker>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockerControllerGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockerControllerGetById(item: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Locker>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockerControllerGetById(item, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PublishLockerDto} publishLockerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockerControllerPublish(publishLockerDto: PublishLockerDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Locker>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockerControllerPublish(publishLockerDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} item 
         * @param {UpdateLockerDto} updateLockerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockerControllerUpdate(item: string, updateLockerDto: UpdateLockerDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Locker>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockerControllerUpdate(item, updateLockerDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LockerApi - factory interface
 * @export
 */
export const LockerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LockerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockerControllerDeleteItem(item: string, options?: any): AxiosPromise<void> {
            return localVarFp.lockerControllerDeleteItem(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockerControllerGet(options?: any): AxiosPromise<Array<Locker>> {
            return localVarFp.lockerControllerGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockerControllerGetById(item: string, options?: any): AxiosPromise<Locker> {
            return localVarFp.lockerControllerGetById(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PublishLockerDto} publishLockerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockerControllerPublish(publishLockerDto: PublishLockerDto, options?: any): AxiosPromise<Locker> {
            return localVarFp.lockerControllerPublish(publishLockerDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} item 
         * @param {UpdateLockerDto} updateLockerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockerControllerUpdate(item: string, updateLockerDto: UpdateLockerDto, options?: any): AxiosPromise<Locker> {
            return localVarFp.lockerControllerUpdate(item, updateLockerDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LockerApi - object-oriented interface
 * @export
 * @class LockerApi
 * @extends {BaseAPI}
 */
export class LockerApi extends BaseAPI {
    /**
     * 
     * @param {string} item 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LockerApi
     */
    public lockerControllerDeleteItem(item: string, options?: AxiosRequestConfig) {
        return LockerApiFp(this.configuration).lockerControllerDeleteItem(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LockerApi
     */
    public lockerControllerGet(options?: AxiosRequestConfig) {
        return LockerApiFp(this.configuration).lockerControllerGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} item 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LockerApi
     */
    public lockerControllerGetById(item: string, options?: AxiosRequestConfig) {
        return LockerApiFp(this.configuration).lockerControllerGetById(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PublishLockerDto} publishLockerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LockerApi
     */
    public lockerControllerPublish(publishLockerDto: PublishLockerDto, options?: AxiosRequestConfig) {
        return LockerApiFp(this.configuration).lockerControllerPublish(publishLockerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} item 
     * @param {UpdateLockerDto} updateLockerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LockerApi
     */
    public lockerControllerUpdate(item: string, updateLockerDto: UpdateLockerDto, options?: AxiosRequestConfig) {
        return LockerApiFp(this.configuration).lockerControllerUpdate(item, updateLockerDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrderControllerApi - axios parameter creator
 * @export
 */
export const OrderControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/catalog/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerGetById: async (item: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('orderControllerGetById', 'item', item)
            const localVarPath = `/api/catalog/order/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerPay: async (item: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('orderControllerPay', 'item', item)
            const localVarPath = `/api/catalog/order/{item}/pay`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PublishOrderDto} publishOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerPublish: async (publishOrderDto: PublishOrderDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publishOrderDto' is not null or undefined
            assertParamExists('orderControllerPublish', 'publishOrderDto', publishOrderDto)
            const localVarPath = `/api/catalog/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publishOrderDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderControllerApi - functional programming interface
 * @export
 */
export const OrderControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerGetById(item: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerGetById(item, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerPay(item: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerPay(item, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PublishOrderDto} publishOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerPublish(publishOrderDto: PublishOrderDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerPublish(publishOrderDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrderControllerApi - factory interface
 * @export
 */
export const OrderControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerGet(options?: any): AxiosPromise<Array<Order>> {
            return localVarFp.orderControllerGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerGetById(item: string, options?: any): AxiosPromise<Order> {
            return localVarFp.orderControllerGetById(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerPay(item: string, options?: any): AxiosPromise<Order> {
            return localVarFp.orderControllerPay(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PublishOrderDto} publishOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerPublish(publishOrderDto: PublishOrderDto, options?: any): AxiosPromise<Order> {
            return localVarFp.orderControllerPublish(publishOrderDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderControllerApi - object-oriented interface
 * @export
 * @class OrderControllerApi
 * @extends {BaseAPI}
 */
export class OrderControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public orderControllerGet(options?: AxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).orderControllerGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} item 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public orderControllerGetById(item: string, options?: AxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).orderControllerGetById(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} item 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public orderControllerPay(item: string, options?: AxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).orderControllerPay(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PublishOrderDto} publishOrderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public orderControllerPublish(publishOrderDto: PublishOrderDto, options?: AxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).orderControllerPublish(publishOrderDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrgControllerApi - axios parameter creator
 * @export
 */
export const OrgControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UpdateOrganizationDto} updateOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgControllerUpdate: async (updateOrganizationDto: UpdateOrganizationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateOrganizationDto' is not null or undefined
            assertParamExists('orgControllerUpdate', 'updateOrganizationDto', updateOrganizationDto)
            const localVarPath = `/api/catalog/org`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrganizationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrgControllerApi - functional programming interface
 * @export
 */
export const OrgControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrgControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UpdateOrganizationDto} updateOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgControllerUpdate(updateOrganizationDto: UpdateOrganizationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgControllerUpdate(updateOrganizationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrgControllerApi - factory interface
 * @export
 */
export const OrgControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrgControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {UpdateOrganizationDto} updateOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgControllerUpdate(updateOrganizationDto: UpdateOrganizationDto, options?: any): AxiosPromise<Organization> {
            return localVarFp.orgControllerUpdate(updateOrganizationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrgControllerApi - object-oriented interface
 * @export
 * @class OrgControllerApi
 * @extends {BaseAPI}
 */
export class OrgControllerApi extends BaseAPI {
    /**
     * 
     * @param {UpdateOrganizationDto} updateOrganizationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgControllerApi
     */
    public orgControllerUpdate(updateOrganizationDto: UpdateOrganizationDto, options?: AxiosRequestConfig) {
        return OrgControllerApiFp(this.configuration).orgControllerUpdate(updateOrganizationDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PayoutsControllerApi - axios parameter creator
 * @export
 */
export const PayoutsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutControllerGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/catalog/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutControllerGetById: async (item: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('payoutControllerGetById', 'item', item)
            const localVarPath = `/api/catalog/payouts/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PublishPayoutDto} publishPayoutDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutControllerPublish: async (publishPayoutDto: PublishPayoutDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publishPayoutDto' is not null or undefined
            assertParamExists('payoutControllerPublish', 'publishPayoutDto', publishPayoutDto)
            const localVarPath = `/api/catalog/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publishPayoutDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} item 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutControllerUpdate: async (item: string, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('payoutControllerUpdate', 'item', item)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('payoutControllerUpdate', 'body', body)
            const localVarPath = `/api/catalog/payouts/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayoutsControllerApi - functional programming interface
 * @export
 */
export const PayoutsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PayoutsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payoutControllerGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payout>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payoutControllerGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payoutControllerGetById(item: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payoutControllerGetById(item, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PublishPayoutDto} publishPayoutDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payoutControllerPublish(publishPayoutDto: PublishPayoutDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payoutControllerPublish(publishPayoutDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} item 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payoutControllerUpdate(item: string, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payoutControllerUpdate(item, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PayoutsControllerApi - factory interface
 * @export
 */
export const PayoutsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PayoutsControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutControllerGet(options?: any): AxiosPromise<Array<Payout>> {
            return localVarFp.payoutControllerGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutControllerGetById(item: string, options?: any): AxiosPromise<Payout> {
            return localVarFp.payoutControllerGetById(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PublishPayoutDto} publishPayoutDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutControllerPublish(publishPayoutDto: PublishPayoutDto, options?: any): AxiosPromise<Payout> {
            return localVarFp.payoutControllerPublish(publishPayoutDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} item 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutControllerUpdate(item: string, body: object, options?: any): AxiosPromise<Payout> {
            return localVarFp.payoutControllerUpdate(item, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PayoutsControllerApi - object-oriented interface
 * @export
 * @class PayoutsControllerApi
 * @extends {BaseAPI}
 */
export class PayoutsControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsControllerApi
     */
    public payoutControllerGet(options?: AxiosRequestConfig) {
        return PayoutsControllerApiFp(this.configuration).payoutControllerGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} item 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsControllerApi
     */
    public payoutControllerGetById(item: string, options?: AxiosRequestConfig) {
        return PayoutsControllerApiFp(this.configuration).payoutControllerGetById(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PublishPayoutDto} publishPayoutDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsControllerApi
     */
    public payoutControllerPublish(publishPayoutDto: PublishPayoutDto, options?: AxiosRequestConfig) {
        return PayoutsControllerApiFp(this.configuration).payoutControllerPublish(publishPayoutDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} item 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsControllerApi
     */
    public payoutControllerUpdate(item: string, body: object, options?: AxiosRequestConfig) {
        return PayoutsControllerApiFp(this.configuration).payoutControllerUpdate(item, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerDeleteItem: async (item: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('productControllerDeleteItem', 'item', item)
            const localVarPath = `/api/catalog/products/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/catalog/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerGetById: async (item: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('productControllerGetById', 'item', item)
            const localVarPath = `/api/catalog/products/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PublishProductDto} publishProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerPublish: async (publishProductDto: PublishProductDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publishProductDto' is not null or undefined
            assertParamExists('productControllerPublish', 'publishProductDto', publishProductDto)
            const localVarPath = `/api/catalog/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publishProductDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} item 
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerUpdate: async (item: string, updateProductDto: UpdateProductDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('productControllerUpdate', 'item', item)
            // verify required parameter 'updateProductDto' is not null or undefined
            assertParamExists('productControllerUpdate', 'updateProductDto', updateProductDto)
            const localVarPath = `/api/catalog/products/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerDeleteItem(item: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerDeleteItem(item, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Product>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerGetById(item: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerGetById(item, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PublishProductDto} publishProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerPublish(publishProductDto: PublishProductDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerPublish(publishProductDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} item 
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerUpdate(item: string, updateProductDto: UpdateProductDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerUpdate(item, updateProductDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerDeleteItem(item: string, options?: any): AxiosPromise<void> {
            return localVarFp.productControllerDeleteItem(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerGet(options?: any): AxiosPromise<Array<Product>> {
            return localVarFp.productControllerGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerGetById(item: string, options?: any): AxiosPromise<Product> {
            return localVarFp.productControllerGetById(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PublishProductDto} publishProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerPublish(publishProductDto: PublishProductDto, options?: any): AxiosPromise<Product> {
            return localVarFp.productControllerPublish(publishProductDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} item 
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerUpdate(item: string, updateProductDto: UpdateProductDto, options?: any): AxiosPromise<Product> {
            return localVarFp.productControllerUpdate(item, updateProductDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @param {string} item 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productControllerDeleteItem(item: string, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).productControllerDeleteItem(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productControllerGet(options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).productControllerGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} item 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productControllerGetById(item: string, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).productControllerGetById(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PublishProductDto} publishProductDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productControllerPublish(publishProductDto: PublishProductDto, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).productControllerPublish(publishProductDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} item 
     * @param {UpdateProductDto} updateProductDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productControllerUpdate(item: string, updateProductDto: UpdateProductDto, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).productControllerUpdate(item, updateProductDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaxonomyApi - axios parameter creator
 * @export
 */
export const TaxonomyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomyControllerDeleteItem: async (item: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('taxonomyControllerDeleteItem', 'item', item)
            const localVarPath = `/api/catalog/taxonomy/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomyControllerGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/catalog/taxonomy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomyControllerGetById: async (item: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('taxonomyControllerGetById', 'item', item)
            const localVarPath = `/api/catalog/taxonomy/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PublishTaxonomyDto} publishTaxonomyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomyControllerPublish: async (publishTaxonomyDto: PublishTaxonomyDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publishTaxonomyDto' is not null or undefined
            assertParamExists('taxonomyControllerPublish', 'publishTaxonomyDto', publishTaxonomyDto)
            const localVarPath = `/api/catalog/taxonomy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publishTaxonomyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} item 
         * @param {UpdateTaxonomyDto} updateTaxonomyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomyControllerUpdate: async (item: string, updateTaxonomyDto: UpdateTaxonomyDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('taxonomyControllerUpdate', 'item', item)
            // verify required parameter 'updateTaxonomyDto' is not null or undefined
            assertParamExists('taxonomyControllerUpdate', 'updateTaxonomyDto', updateTaxonomyDto)
            const localVarPath = `/api/catalog/taxonomy/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaxonomyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaxonomyApi - functional programming interface
 * @export
 */
export const TaxonomyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaxonomyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxonomyControllerDeleteItem(item: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxonomyControllerDeleteItem(item, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxonomyControllerGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Taxonomy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxonomyControllerGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxonomyControllerGetById(item: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Taxonomy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxonomyControllerGetById(item, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PublishTaxonomyDto} publishTaxonomyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxonomyControllerPublish(publishTaxonomyDto: PublishTaxonomyDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Taxonomy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxonomyControllerPublish(publishTaxonomyDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} item 
         * @param {UpdateTaxonomyDto} updateTaxonomyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxonomyControllerUpdate(item: string, updateTaxonomyDto: UpdateTaxonomyDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Taxonomy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxonomyControllerUpdate(item, updateTaxonomyDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaxonomyApi - factory interface
 * @export
 */
export const TaxonomyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaxonomyApiFp(configuration)
    return {
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomyControllerDeleteItem(item: string, options?: any): AxiosPromise<void> {
            return localVarFp.taxonomyControllerDeleteItem(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomyControllerGet(options?: any): AxiosPromise<Array<Taxonomy>> {
            return localVarFp.taxonomyControllerGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomyControllerGetById(item: string, options?: any): AxiosPromise<Taxonomy> {
            return localVarFp.taxonomyControllerGetById(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PublishTaxonomyDto} publishTaxonomyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomyControllerPublish(publishTaxonomyDto: PublishTaxonomyDto, options?: any): AxiosPromise<Taxonomy> {
            return localVarFp.taxonomyControllerPublish(publishTaxonomyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} item 
         * @param {UpdateTaxonomyDto} updateTaxonomyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomyControllerUpdate(item: string, updateTaxonomyDto: UpdateTaxonomyDto, options?: any): AxiosPromise<Taxonomy> {
            return localVarFp.taxonomyControllerUpdate(item, updateTaxonomyDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaxonomyApi - object-oriented interface
 * @export
 * @class TaxonomyApi
 * @extends {BaseAPI}
 */
export class TaxonomyApi extends BaseAPI {
    /**
     * 
     * @param {string} item 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyApi
     */
    public taxonomyControllerDeleteItem(item: string, options?: AxiosRequestConfig) {
        return TaxonomyApiFp(this.configuration).taxonomyControllerDeleteItem(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyApi
     */
    public taxonomyControllerGet(options?: AxiosRequestConfig) {
        return TaxonomyApiFp(this.configuration).taxonomyControllerGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} item 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyApi
     */
    public taxonomyControllerGetById(item: string, options?: AxiosRequestConfig) {
        return TaxonomyApiFp(this.configuration).taxonomyControllerGetById(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PublishTaxonomyDto} publishTaxonomyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyApi
     */
    public taxonomyControllerPublish(publishTaxonomyDto: PublishTaxonomyDto, options?: AxiosRequestConfig) {
        return TaxonomyApiFp(this.configuration).taxonomyControllerPublish(publishTaxonomyDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} item 
     * @param {UpdateTaxonomyDto} updateTaxonomyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyApi
     */
    public taxonomyControllerUpdate(item: string, updateTaxonomyDto: UpdateTaxonomyDto, options?: AxiosRequestConfig) {
        return TaxonomyApiFp(this.configuration).taxonomyControllerUpdate(item, updateTaxonomyDto, options).then((request) => request(this.axios, this.basePath));
    }
}


